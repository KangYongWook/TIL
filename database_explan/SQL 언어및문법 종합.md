# SQL 언어

### 테이블값

```sql
SELECT * FROM DEPT;
SELECT * FROM EMP; //EMP데이터 전체출력
SELECT * FROM T_USER; // 테이블 T_USER안에 정보값
```

### 테이블 속성

```sql
DESC T_USER;-> T_USER에 있는 정보 출력
```

# 1.DDL

### CREATE  -> 테이블을 만든다.

```  sql
CREATE TABLE T_USER(

 	ID	  VARCHAR2(10),  //   COLUMN은 ID  //DATA TYPE은 VARCHAR2 //  LENGTH는 10

   PWD  VARCHAR2(10),

   NAME VARCHAR2(20)

);


CREATE TABLE T_PRODUCT(
   ID VARCHAR2(10) PRIMARY KEY,
   NAME VARCHAR2(20) NOT NULL,
   PRICE NUMBER(10,1)NOT NULL,  // 넣으면 짤려서 소숫점 1까지만들어감 (10)은 정수만
   REGDATE DATE NOT NULL
);

```

### 테이블삭제 

- 완전히 삭제되므로 조심할것

```  sql
DROP TABLE  테이블명;
```

### 테이블속성 변경

```SQl
DESC PRODUCT; // 테이블에 들어간 값을 확인한다.
ALTER TABLE T_PRODUCT RENAME TO PRODUCT; // TABLE 이름을 바꾼다.
ALTER TABLE PRODUCT RENAME COLUMN PRICE TO T_PRICE;  // PRODUCT 의 테이블에 COLUME행에 PRICE를 T_PRICE로 수정
ALTER TABLE T_PRODUCT MODIFY( NAME NOT NULL)); // 이름안에 값을 NULL로 수정한다
ALTER TABLE T_PRODUCT RENAME COLUMN NAME TO UNAME; //이름을 변경해준다
ALTER TABLE T_PRODUCT MODIFY( NAME CHAR(10)) ; //사이즈변경
ALTER TABLE T_PRODUCT ADD (REGDATE DATE); // REGDATE열 추가 데이터타입은 DATE
ALTER TABLE PRODUCT DROP COLUMN REGDATE ; //  REGDATE열 삭제
ALTER TABLE T_PRODUCT ADD PRIMARY KEY(ID); // KEY등록 중복되는걸 방지한ㄷ.
ALTER TABLE PRODUCTS ADD [CONSTRAINT FK] FOREIGN KEY (FACTNO) REFERENCES FACTORY (FACTNO) 
//예약어로 TABLE명 선언시도 오류뜸 

ALTER TABLE T_USER MODIFY (NAME UNIQUE); // NAME에는 NULL이들어갈수없다.  유니크하게만들어줌
ALTER TABLE T_PRODUCT MODIFY(PRICE DEFAULT 1000); // 다음번부터 넣을 디폴트값에 1000을 넣어줌  이미 들어간 디폴트값에는 안들어감 
```





# 2.DML -> CRUD

### SELECT 선택문

####  AS, AND,OR,NOT,ORDER,LIKE,NVL,IS 등등..

```SQL
SELECT ENAME,SAL FROM EMP; // ENAME행이랑 SAL행만출력됨

SELECT * FROM EMP WHERE ENAME = 'KING'; // 킹네임 행만출력

SELECT ENAME,SAL,DEPTNO AS DNO  FROM EMP;// DEPTINO를 DNO로 재정의

SELECT ENAME,SAL,SAL*12 AS ASAL,DEPTNO AS DNO  FROM EMP; // SAL에서 12를 곱한 행을 추가하고 이름을 ASAL로 재정의

SELECT ENAME,SAL,SAL*12 AS "ANN SAL",DEPTNO AS DNO  FROM EMP; // 위에서 다르게 띄어쓰기한 이름을 만들어줄떄는 ""안에넣어줌  

SELECT 
ENAME || JOB AS eNAMEANDJOB
FROM
EMP;
// ENAME행과 JOB행을합치고 재정의

SELECT 
ENAME || ' ' || SAL AS ENAMEANDJOB
FROM
EMP;

// ENAME 행과 SAL행을 합치고 사이에 띄어쓰기 그리고 이름재정의 

SELECT 
DISTINCT(JOB)
FROM
EMP;

// 중복된거 제거

SELECT *FROM EMP
WHERE JOB = 'MANAGER' ;

// 잡이 매니저인거만 출력 

SELECT *FROM EMP
WHERE JOB = 'MANAGER' 
AND SAL > 2500 ; 
// MANAGER 과 SAL이 2500초과인것

SELECT *FROM EMP
WHERE JOB = 'MANAGER' 
AND SAL > 2500 
AND HIREDATE > '04/14/1981' ;
// MANAGER 과 SAL이 2500초과 날짜도 04 14 1981 초과

SELECT *FROM EMP
WHERE JOB = 'MANAGER' 
AND ENAME LIKE '%A%'
// JOB 이 MANAGER이고 ENAME에 A가 들어간것

SELECT ENAME,SAL,SAL + COMM
FROM EMP;
// 이렇게 똑같은거 여러가지도 가능 중복도가능 


SELECT ENAME,SAL,
((SAL *12) *0.87 )+ ((NVL(COMM ,0) * 12) *0.88) AS  TOTAL
FROM EMP;

-- 연봉을 계산 하시오 단, SAL의 세금은 13%, COMM에 세금은 12% 
여기서 NLV은 NULL값에 0을 넣어줌

SELECT ENAME,SAL,
((SAL *12) *0.87 )+ ((NVL(COMM ,0) * 12) *0.88) AS  ANSAL
FROM EMP
WHERE ANSAL > 30000 -- 여기서 이건안됨 프로그램이 시작하고 데이터가들어가기떄매안됨
WHERE ((SAL *12) *0.87 )+ ((NVL(COMM ,0) * 12) *0.88)  >30000 //여기서 >기호말고도 사칙연산 조건연산자도가능 들어갈수있음 그대신 !는안됨(오라클에서만 제공)대신 <>를 사용
//연봉이 3만이상

-- 연봉을 계산 하시오 단, SAL의 세금은 13%, COMM에 세금은 12%  

SELECT ENAME FROM EMP
WHERE ENAME > 'V'
//맨앞글자가 V보다 큰거 A~Z 

SELECT * FROM EMP
WHERE COMM IS NULL;
// NULL같은경우 비교연산자가안됨 그래서 =대신 IS사용


SELECT * FROM EMP
WHERE COMM IS NOT NULL;

// NULL 값이 아닌것을 찾음

SELECT * FROM EMP
WHERE SAL < 2000
AND DEPTNO=30
OR ENAME LIKE '%E%';
// SAL 이 2000보다작고 그리고 DEPTNO가 30인것을 찾고 그리고 ENAME에 E가들어간걸 모두찾아서합침
그래서 EPTNO나 SAL이 조건에 안맞게 들어갈수잇음
그래서 밑에처럼묶어줌

SELECT * FROM EMP
WHERE JOB = 'CLERK'
AND (DEPTNO = 10  OR DEPTNO = 20)

SELECT * FROM EMP
WHERE DEPTNO = '10'
OR DEPTNO = '30'
// 둘다 충족

SELECT * FROM EMP
WHERE JOB = 'CLERK'
AND NOT (DEPTNO = 10  OR DEPTNO = 20)
// NOT은 연산자뒤에 붙여준다

SELECT ENAME,SAL FROM EMP
ORDER BY SAL  
// SAL 순으로 작은거부터
SELECT ENAME,SAL FROM EMP
ORDER BY SAL DESC 
// 큰거부터정렬

SELECT ENAME,SAL FROM EMP
ORDER BY SAL ASC
// 작은거부터정렬

SELECT ENAME,SAL,DEPTNO FROM EMP
WHERE SAL>1000
AND DEPTNO = 20
ORDER BY 1 ASC
// ORDER BY는 맨밑에 들어감 그리고 1은 ENAME 2는 SAL 차례때로

SELECT ENAME,SAL,DEPTNO,SAL *12 AS ASAL FROM EMP
WHERE SAL>1000
AND DEPTNO = 20
ORDER BY ASAL
//이름변경시 사용가능

SELECT * FROM EMP
WHERE MGR IS NOT NULL
ORDER BY MGR,ENAME
// EMP를 불러오고 MGR 이 0 이아닌것 그리고 MGR로 정렬후 ENAME순으로 정렬

```



## INSERT 삽입문

```sql
INSERT INTO T_USER (ID,PWD,NAME) VALUES ('ID01','PWD01','이말숙');
INSERT INTO T_USER (ID,PWD) VALUES ('ID01','PWD01');

INSERT INTO T_USER (ID,PWD,NAME) VALUES ('ID07', 'PED07',' '); // null값을 넣어줌
INSERT INTO T_PRODUCT VALUES('P01','PNTS;,20000,SYSDATE); // 여기서 SYSDATE는 컴퓨터 시간
                             
INSERT INTO T_PRODUCT VALUES('P07','PNTS2',100.36,SYSDATE); // 소수점은 2번쨰자리부터 반올림해서 들어감 
INSERT INTO T_PRODUCT VALUES('P03','PNTS3',' ',SYSDATE); //순서대로넣는것
INSERT INTO T_PRODUCT (ID,NAME,REGDATE) VALUES('P09','PNTS4',SYSDATE); //지정해서넣는거                            
```



## DELETE 제거문

```sql
DELETE FROM T_USER; // 다삭제 위험함
DELETE FROM T_USER WHERE ID='ID02';  // WHERE다음에 조건들어감 ID02가들어간 열삭제
```



## UPDATE 업데이트

````sql
UPDATE 테이블명 SET PWD= '111', NAME = '공말숙'  // 이렇게되면 모든게 똑같아짐

UPDATE 테이블명 SET PWD= '111', NAME = '공말숙' WHERE ID='ID03' // 조건문을 통해줌 
````



# ROLLBACK & COMMIT

```sql
ROLLBACK;  // Autocommit을 꺼놓은 상태에서 정보를입력후 ROLLBACK를 입력하면 취소가능
COMMIT; // Autocommit 안했을때 COMMIT을 통해 명령 확정
```



# 주석처리 

```SQL
-- WHERE STATEMENT.

/* 
mULTI COMMENTS ..
*/ 

```

# 함수



```SQL
SELECT ENAME,SAL,ABS(SAL) FROM EMP;  //절대값


SELECT ENAME,SAL,SAL/7 FROM EMP;  // 7로나눈 값이 나옴

SELECT ENAME,SAL,ROUND(SAL/7,3) AS BONUS FROM EMP // 반올림함수 3쨰자리에서 반올림 
SELECT ENAME,SAL,ROUND(SAL) AS BONUS FROM EMP // 반올림함수 소숫점없앰 

SELECT ENAME || ' ' || JOB AS EJOB FROM EMP;  // ENAME과 JOB을 합치고 가운데 띄어쓰기하고 이름 재정의
SELECT LOWER (ENAME) || ' ' || JOB AS EJOB FROM EMP; //LOWER -> 소문자

SELECT ENAME, SUBSTR(ENAME, 1,3) FROM EMP; // ENAME에서 1번쨰부터 3번쨰까지 나옴  

SELECT ENAME, SUBSTR(ENAME, 1,3) ,
REPLACE(ENAME,SUBSTR(ENAME,1,3),'AAA')
FROM EMP; 
//ENAME의 1번째문자부터 3번쨰문자까지 AAA로 바꾼다

SELECT ENAME, SUBSTR(ENAME,1,3),
REPLACE(ENAME,SUBSTR(ENAME,2,LENGTH(ENAME)),LOWER(SUBSTR(ENAME,2,LENGTH(ENAME))))
FROM EMP;

SELECT NAME, LENGTH(NAME) FROM T_USER; //이름의 길이 출력

INSERT INTO T_USER VALUES ('ID788','PWD78','가나다'); //한글은 한개당 3개공간

SELECT ENAME,SUBSTR(SAL,1,2)*10 FROM EMP; // STR값이지만 숫자면 *10 가능

SELECT ENAME, SAL FROM EMP
WHERE DEPTNO=  20 OR DEPTNO=30;
//밑이랑 같은말임
SELECT ENAME,SAL,DEPTNO FROM EMP
WHERE DEPTNO IN (20,30);
// 위에랑 같은말 DEPTNO에 20과 30이 들어가있는걸 출력 

SELECT ENAME,TO_CHAR(CURRENT_TIMESTAMP,'YYYY:MM:DD'),
TO_CHAR(HIREDATE,'YYYY/MM/DD'),SYSDATE, // TO CHAR 현재 데이터를 내원하는 데이터순으로 바꾼다.  여기서 TO_CHAR(HIREDATE,'MM')  이러면 월만출력 
SYSDATE - HIREDATE,
HIREDATE,
FROM EMP;

INSERT INTO T_PRODUCT VALUES ('ID99', 'PANTS',10000,TO_DATE('2010/10/11','YY:MM:DD'))
// 날짜칸에는 스트링으로 넣으면안들어가서 T_DATE로 날짜값으로바꿔줌

SELECT ENAME,NVL2(COMM,'0','1') FROM EMP; // NULL이면 0 숫자가있으면 1 

SELECT ENAME,HIREDATE, // HIREDATE ->고용날짜

SYSDATE-HIREDATE ,// 일수로나옴

MONTHS_BETWEEN(SYSDATE,HIREDATE)// 달수계싼해줌 함수임
FROM EMP

SELECT ENAME,SAL FROM EMP
WHERE SAL BETWEEN 2000 AND 5000
2000이상 5000이하

```

# 술어 

#### CASE

```SQL

SELECT ENAME,
CASE WHEN  JOB= 'PRESIDENT'
     THEN '왕'	
     WHEN JOB= 'MANAGER'
     THEN '관리자'
     ELSE '직원'
END
FROM EMP


SELECT ENAME,SAL,SAL*12,
CASE WHEN  SAL *12 >= 5000
     THEN '왕'
     WHEN SAL*12 >= 3000 AND SAL*12 < 5000
     THEN '관리자'
     ELSE '직원'
END AS GRADE
FROM EMP
ORDER BY GRADE

```

# 집약과 정렬 //  그룹함수가 있을때만 사용가능

````SQL
SELECT COUNT(ENAME)  FROM EMP; // ENAME 갯수
SELECT SUM(SAL)  FROM EMP;// SAL총합
SELECT MAX(SAL) AS CNT  FROM EMP;
SELECT MIN(SAL) AS CNT  FROM EMP;
SELECT AVG(SAL) AS CNT  FROM EMP;

SELECT COUNT(NVL(COMM,0)) AS CNT FROM EMP; // NULL값 0만들어줘서 14개
SELECT COUNT(COMM) AS CNT FROM EMP; // NULL값을 제외하고 카운트 4추력

SELECT ROUND(AVG(SAL)), SUM(NVL(COMM,0)) FROM EMP
SELECT MIN(SAL), MAX(SAL), SUM(SAL), AVG(SAL) FROM EMP
SELECT MIN(HIREDATE ) FROM EMP // 날짜는 SUM,AVG는안됨 MIN MAX만가능 
SELECT SUM(SAL), SUM(DISTINCT SAL) FROM EMP; // DISTINCT << 중복제거


SELECT  JOB,SUM(SAL) FROM EMP
GROUP BY JOB

SELECT DEPTNO,JOB,SUM(SAL) FROM EMP
GROUP BY DEPTNO,JOB
ORDER BY DEPTNO


SELECT DEPTNO,JOB,SUM(SAL) FROM EMP
GROUP BY DEPTNO,JOB
HAVING DEPTNO IN(10,20) AND JOB LIKE '%E%' // 그룹문에서는 조건을 HAVING으로 사용한다.
ORDER BY DEPTNO

// JOB 별 중에서 E 가 들어간 JOB 월급평균
SELECT JOB ,AVG(SAL) FROM EMP
GROUP BY JOB
HAVING JOB LIKE '%E%'


//JOB 별 월급의 평균 단 DEPTNO 가 10,20 직원대상
SELECT JOB, SVA(SAL ) FROM EMP
WHERE DEPTNO IN(10,20) // 그룹핑 이외에 조건은 WHERE로 한다 
GROUP BY JOB




DEPTNO별 JOB별 월급의 평균을 구하시오 
단, 이름에 A 가 들어간 직원들을 대상으로 하시오 DEPTNO 20,30 부서를 대상으로 하시오 또한  월급의 평균이 1000 이상인것을 대상으로 하시오
단 COMM도 NULL 값인것.

SELECT DEPTNO,JOB,AVG(SAL) FROM EMP
WHERE ENAME LIKE '%A%' AND COMM IS NULL
GROUP BY DEPTNO,JOB
HAVING AVG(SAL)>=1000 AND DEPTNO IN (20,30)
ORDER BY DEPTNO

년도 별 입사자의 월급의 평균을 구하시오 단 매니저만 

SELECT TO_CHAR(HIREDATE,'YYYY'),JOB,AVG(SAL)  FROM EMP
WHERE JOB IN('MANAGER')
GROUP BY  TO_CHAR(HIREDATE,'YYYY'),JOB


SELECT JOB, AVG(SAL) FROM EMP
WHERE JOB IN ('MANAGER','CLERK') // JOB 은 GROUP화되있지만 WHERE도되고 HAVING도가능
GROUP BY JOB
HAVING AVG(SAL) >= 2000



````

# VIEW 생성

```SQL
CREATE VIEW EMPSALVIEW(ENAME,ANNSAL)
AS
SELECT ENAME, (SAL * 12 ) + (NVL(COMM,0)*12) FROM EMP   

// VIEW DATA를 생성해줌  EMP로부터 제목 ENAME과 다음꺼 를 EMPSALVIEW에 ENAME,ANNSAL제목으로 생성 


SELECT * FROM  EMPSALVIEW  --> EMPSALVIEW 내용보여달라.

```

